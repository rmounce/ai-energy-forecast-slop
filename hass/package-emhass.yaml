template:
  - sensor:
    - name: 'Amber Effective General Price'
      unit_of_measurement: "$/kWh"
      device_class: monetary
      state: >
        {% set ns = namespace(value='unknown') %}
        {%- if as_datetime(state_attr('sensor.amber_5min_current_general_price', 'end_time')) > utcnow() %}
          {%- set ns.value = states('sensor.amber_5min_current_general_price') %}
        {%- else %}
          {%- for item in state_attr('sensor.amber_5min_forecasts_general_price', 'Forecasts') %}
            {%- if ns.value == 'unknown' and as_datetime(item.end_time) > utcnow() %}
              {%- set k = states('input_number.emhass_weight_forecast_probability') | float(0.5) %}
              {%- set p50_buy = item.advanced_price_predicted %}
              {%- set p90_buy = item.advanced_price_high %}
              {%- set adjusted_buy_price = p50_buy + (p90_buy - p50_buy) * k %}
              {%- set ns.value = [adjusted_buy_price, item.per_kwh] | max %}
            {%- endif %}
          {%- endfor %}
        {%- endif %}
        {{ ns.value }}

    - name: 'Amber Effective Feed In Price'
      unit_of_measurement: "$/kWh"
      device_class: monetary
      state: >
        {% set ns = namespace(value='unknown') %}
        {%- if as_datetime(state_attr('sensor.amber_5min_current_feed_in_price', 'end_time')) > utcnow() %}
          {%- set ns.value = states('sensor.amber_5min_current_feed_in_price') %}
        {%- else %}
          {%- for item in state_attr('sensor.amber_5min_forecasts_feed_in_price', 'Forecasts') %}
            {%- if ns.value == 'unknown' and as_datetime(item.end_time) > utcnow() %}
              {#- Get the risk aversion factor 'k' #}
              {%- set k = states('input_number.emhass_weight_forecast_probability') | float(0.5) %}
              {#- Input numbers are negated, fix them: #}
              {%- set p10_sell = -item.advanced_price_low %}
              {%- set p50_sell = -item.advanced_price_predicted %}
              {%- set per_kwh_sell = -item.per_kwh %}
              {#- Calculate the adjusted price (moves from p50 towards p10) #}
              {%- set adjusted_sell_price = p50_sell + (p10_sell - p50_sell) * k %}
              {%- set ns.value = [adjusted_sell_price, per_kwh_sell] | min %}
            {%- endif %}
          {%- endfor %}
        {%- endif %}
        {{ ns.value }}

rest_command:
  emhass_dayahead_optim:
    url: http://emhass.REDACTED/action/naive-mpc-optim
    method: POST
    timeout: 120
    headers:
      content-type: application/json
    payload: >-
      {
        "entity_save": true,
        "publish_prefix":"dh_",
        {#-
          {%- set current_pv_interval = utcnow() - timedelta(minutes=30) %}
          
          ['sensor.solcast_pv_forecast_forecast_today', 'sensor.solcast_pv_forecast_forecast_tomorrow', 'sensor.solcast_pv_forecast_forecast_day_3', 'sensor.solcast_pv_forecast_forecast_day_4']
          | map('state_attr', 'detailedForecast')
          | map('selectattr', 'period_start', 'gt', current_pv_interval)
          | map('list') | sum(start=[])
          | map(attribute='pv_estimate')
          | map('multiply', 1000)
          #}
        {%- set pv_forecast = namespace(values=[]) %}
        {#- Subtract 100W from PV forecast to prevent overestimating sunset / sunrise #}
        {%- for v in state_attr('sensor.ai_pv_forecast', 'forecasts')| map(attribute='power_pv')
          | map('add', -100)
          | map('int') %}
          {%- if v > 0 %}
            {%- set pv_forecast.values = pv_forecast.values + [v] %}
          {%- else %}
            {%- set pv_forecast.values = pv_forecast.values + [0] %}
          {%- endif %}
        {%- endfor %}
        "pv_power_forecast": {{ pv_forecast.values | tojson }},
        {#- Correction factor for load power forecast #}
        "load_power_forecast": {{ state_attr('sensor.ai_load_forecast', 'forecasts')| map(attribute='power_load')|map('multiply', 1.0)|map('round',0)|list|tojson }},

        {#- ========================================================================================= #}
        {#-            START: DAY-AHEAD TWO-KNOB DYNAMIC PRICING LOGIC                    -#}
        {#- ========================================================================================= #}

        {#- Knob 1: Get the risk aversion factor 'k' from your input helper. #}
        {%- set k = states('input_number.emhass_weight_forecast_probability') | float(0.5) %}

        {#- Knob 2: Get the profitability hurdle from your input helper. #}
        {%- set discharge_weight = states('input_number.emhass_weight_battery_discharge') | float(0.02) %}

        {#- Prepare empty lists to store the new forecasts. #}
        {%- set data = namespace(load_cost_list=[], prod_price_list=[]) %}

        {#- Pre-load all forecast data sources into variables. #}
        {%- set p50_forecasts = state_attr('sensor.ai_price_forecast', 'forecasts') %}
        {%- set p10_forecasts = state_attr('sensor.ai_price_forecast_p10', 'forecasts') %}
        {%- set p90_forecasts = state_attr('sensor.ai_price_forecast_p90', 'forecasts') %}

        {#- Loop through the forecasts by index to process them in parallel. #}
        {%- for i in range(p50_forecasts | length) %}

          {#- --- Process BUY Price (load_cost) --- #}
          {%- set p50_buy = p50_forecasts[i].general_price %}
          {%- set p90_buy = p90_forecasts[i].general_price %}
          {%- set adjusted_buy_price = p50_buy + (p90_buy - p50_buy) * k %}
          {%- set data.load_cost_list = data.load_cost_list + [adjusted_buy_price | round(4)] %}

          {#- --- Process SELL Price (prod_price) --- #}
          {%- set p10_sell = p10_forecasts[i].feed_in_price %}
          {%- set p50_sell = p50_forecasts[i].feed_in_price %}
          {%- set adjusted_sell_price = p50_sell + (p10_sell - p50_sell) * k %}
          {#- Step 3: Negate the final price before appending for EMHASS. #}
          {%- set data.prod_price_list = data.prod_price_list + [adjusted_sell_price | round(4)] %}

        {%- endfor %}

        "load_cost_forecast": {{ data.load_cost_list | tojson }},
        "prod_price_forecast": {{ data.prod_price_list | tojson }},
        "weight_battery_discharge": {{ discharge_weight }},

        {#- ========================================================================================= #}
        {#-             END: DAY-AHEAD TWO-KNOB DYNAMIC PRICING LOGIC                     -#}
        {#- ========================================================================================= #}
        
        "optimization_time_step": 30,
        "prediction_horizon": 144,
        {#- UNSURE WHY THESE ARE NEEDED #}
        "delta_forecast": 3,
        "alpha": 1,
        "beta": 0,
        "sensor_power_photovoltaics": "sensor.sigen_plant_pv_power",
        {#- END UNSURE #}
        "battery_minimum_state_of_charge": 0.15, 
        "soc_init": {{ ((states('sensor.sigen_plant_battery_state_of_charge') | float) / 100) | round(4) }},
        {#- "soc_final": 1.0 #}
        {# bias charging by taking max(Current, T+24h, T+48h)+5% as the target for T+74h #}
        {#-
        {%- set max_forecast_soc = ([ states('sensor.sigen_plant_battery_state_of_charge') | float,
          state_attr('sensor.dh_soc_batt_forecast', 'battery_scheduled_soc')[48].dh_soc_batt_forecast | float,
          state_attr('sensor.dh_soc_batt_forecast', 'battery_scheduled_soc')[96].dh_soc_batt_forecast | float
        ] | sort)[-1] %}
        #}
        {#- "soc_final": {{ (([max_forecast_soc + 5, 100] | sort)[0] / 100) | round(4) }} #}
        {#- Current plus 20%, min 15%, max 100% #}
        "soc_final": {{ ([15, (states('sensor.sigen_plant_battery_state_of_charge') | float) + 20, 100] | sort)[1]/100 | round(4) }}
      }

  emhass_publish_data_dh:
    url: http://emhass.REDACTED/action/publish-data
    method: POST
    headers:
      content-type: application/json
    payload: >-
      {
        "publish_prefix":"dh"
      }

  emhass_mpc:
    url: http://emhass.REDACTED/action/naive-mpc-optim
    method: POST
    timeout: 120
    headers:
      content-type: application/json
    payload: >-
      {
        "entity_save": true,
        "publish_prefix":"mpc_",
        "soc_init": {{ ((states('input_number.battery_soc_5_minute') | float) / 100) | round(4) }},
        {#- Interpolate target SOC based on current time within 30-minute intervals #}
        {%- set now = utcnow() %}
        {%- set endtime = (now + timedelta(hours=12) - timedelta(minutes=30)) %}
        {%- set soc_forecasts = state_attr('sensor.dh_soc_batt_forecast', 'battery_scheduled_soc') %}
        {%- set ns = namespace(end_soc1='unknown',end_soc2='unknown') %}
        {%- for item in state_attr('sensor.dh_soc_batt_forecast', 'battery_scheduled_soc') %}
          {%- if as_datetime(item.date) < endtime %}
            {%- set ns.end_soc1 = item.dh_soc_batt_forecast | float %}
          {%- elif as_datetime(item.date) >= endtime and ns.end_soc2=='unknown' %}
            {%- set ns.end_soc2 = item.dh_soc_batt_forecast | float %}
          {%- endif %}
        {%- endfor %}

        {#- Calculate minutes into current 30-minute period #}
        {#- set minutes_into_period = (now.minute % 30) + (now.second / 60) #}
        {#- Round down to nearest 5 #}
        {%- set minutes_into_period = utcnow().minute % 30 // 5 * 5 %}
        {%- set interpolation_factor = minutes_into_period / 30 %}
        {#- Calculate the base interpolated SOC from the 3-day forecast #}
        {%- set base_soc = ns.end_soc1 * (1 - interpolation_factor) + ns.end_soc2 * interpolation_factor %}
        {#- Add 1% margin to avoid "bleeding" to grid, then clamp the result to a maximum of 100 #}
        {%- set clamped_soc_percent = [base_soc + 1, 100.0] | min %}
        {#- Final output, converted to a decimal and rounded #}
        "soc_final": {{ (clamped_soc_percent / 100) | round(4) }},

        "battery_minimum_state_of_charge": {{ ([5, (states('sensor.sigen_plant_battery_state_of_charge') | float) - 5, 15] | sort)[1]/100 | round(4) }},
        {#- "battery_minimum_state_of_charge": 0.05, #}
        {%- set pv_curtailment = namespace(value=(states('sensor.mpc_p_pv_curtailment') | float(0))) %}
        {%- for item in state_attr('sensor.mpc_p_pv_curtailment', 'forecasts') or [] %}
          {%- if as_datetime(item.date) <= utcnow() %}
            {% set pv_curtailment.value = item.mpc_p_pv_curtailment %}
          {%- endif %}
        {%- endfor %}
        {%- set pv_curtailment_now = pv_curtailment.value | int(0) %}
        {%- set pv_power_now = states('sensor.sigen_plant_pv_power') | int(0) %}

        {%- set load_power_now = states('sensor.power_load_without_losses') | int(0) %}
        {%- set load_cost_now = states('sensor.amber_5min_current_general_price') | float %}
        {%- set prod_price_now = states('sensor.amber_5min_current_feed_in_price') | float %}
        {#- Initialize with current values #}
        {%- set data = namespace(
          load_power_list=[],
          pv_power_list=[],
          load_cost_list=[load_cost_now], 
          prod_price_list=[prod_price_now]
        ) %}


        {#- --------------------------------------------------------------------------------- #}
        {#-            REUSABLE POWER INTERPOLATION MACRO FOR HOME ASSISTANT            -#}
        {#- --------------------------------------------------------------------------------- #}

        {#- A macro is a reusable function in Jinja2. This macro encapsulates the entire #}
        {#- two-stage interpolation logic. It takes the sensor entity, the attribute name,#}
        {#- and the key for the power value as arguments, and returns a final list of     #}
        {#- interpolated 5-minute power values.                                         -#}

        {%- macro interpolate_power_data(entity_id, attribute_name, value_key) -%}
          {#- Create a namespace to hold the lists we build inside the macro. #}
          {%- set d = namespace(thirty_min_values=[], initial_smooth_values=[], final_power_list=[]) %}

          {#- Step 0: Extract just the power values from the specified entity attribute. #}
          {%- for item in state_attr(entity_id, attribute_name) | default([]) %}
            {%- if as_datetime(item.date) > (utcnow() - timedelta(minutes=30)) %}
              {%- set d.thirty_min_values = d.thirty_min_values + [item[value_key] | int(0)] %}
            {%- endif %}
          {%- endfor %}
          {%- set num_periods = d.thirty_min_values | length %}

          {#- If there is no data, return an empty list. #}
          {%- if num_periods == 0 -%}
            {{ [] }}
          {%- else -%}
            {#- STAGE 1: Create an initial list of smoothly interpolated values. #}
            {%- for period_idx in range(num_periods) %}
              {%- set current_power = d.thirty_min_values[period_idx] %}
              {%- set prev_power = d.thirty_min_values[period_idx - 1] if period_idx > 0 else current_power %}
              {%- set next_power = d.thirty_min_values[period_idx + 1] if period_idx < (num_periods - 1) else current_power %}
              {%- set start_value = (prev_power + current_power) / 2.0 %}
              {%- set end_value = (current_power + next_power) / 2.0 %}
              {%- for i in range(6) %}
                {%- set t = (i + 0.5) / 6.0 %}
                {%- set interpolated_point = start_value + t * (end_value - start_value) %}
                {%- set d.initial_smooth_values = d.initial_smooth_values + [interpolated_point] %}
              {%- endfor %}
            {%- endfor %}

            {#- STAGE 2: Correct the averages to generate the final list. #}
            {%- for period_idx in range(num_periods) %}
              {%- set target_average = d.thirty_min_values[period_idx] %}
              {%- set current_block = d.initial_smooth_values[period_idx*6:(period_idx+1)*6] %}
              {%- set residual_error = target_average - (current_block | sum / 6.0) %}
              {%- for value in current_block %}
                {%- set corrected_value = value + residual_error %}
                {%- set final_value = [0, corrected_value | round(0)] | max | int %}
                {%- set d.final_power_list = d.final_power_list + [final_value] %}
              {%- endfor %}
            {%- endfor %}

            {#- Return the final, calculated list. #}
            {{- d.final_power_list | tojson }}
          {%- endif -%}
        {%- endmacro -%}


        {#- Call the macro for the PV forecast. #}
        {%- set data.pv_power_list = interpolate_power_data(
            entity_id='sensor.dh_p_pv_forecast',
            attribute_name='forecasts',
            value_key='dh_p_pv_forecast'
        ) | from_json %}
        {#- Call the exact same macro for the Load forecast. #}
        {#-    NOTE: Adjust the 'value_key' if your load forecast uses a different name. #}
        {%- set data.load_power_list = interpolate_power_data(
            entity_id='sensor.dh_p_load_forecast',
            attribute_name='forecasts',
            value_key='dh_p_load_forecast'
        ) | from_json %}



        {#- Discard periods that have passed #}
        {%- set periods_into_30min = (utcnow().minute % 30)//5 %}
        {%- set data.load_power_list = data.load_power_list[periods_into_30min:] %}
        {%- set data.pv_power_list = data.pv_power_list[periods_into_30min:] %}
        {#- Set first 2 elements to current value #}
        {%- set data.load_power_list = [load_power_now]*2 + data.load_power_list[2:] %}
        {#- If PV is presently being curtailed, take the maximum of the forecast or the currently produced + curtailed power #}
        {%- if pv_curtailment_now > 0 and data.pv_power_list[0] > pv_power_now %}
          {%- set pv_power_now = data.pv_power_list[0] %}
        {%- endif %} 
        {%- set data.pv_power_list = [pv_power_now]*2 + data.pv_power_list[2:] %}

        {#- ========================================================================================= #}
        {#-                  START: TWO-KNOB DYNAMIC PRICING LOGIC                        -#}
        {#- ========================================================================================= #}
        {%- set k = states('input_number.emhass_weight_forecast_probability') | float(0.5) %}
        {#- Process BUY price forecasts (load_cost) #}
        {%- for item in state_attr('sensor.amber_5min_forecasts_extended_general_price', 'Forecasts') %}
          {%- if as_datetime(item.start_time) > now %}
            {%- set p50_buy = item.advanced_price_predicted %}
            {%- set p90_buy = item.advanced_price_high %}
            {%- set adjusted_buy_price = p50_buy + (p90_buy - p50_buy) * k %}
            {%- if (as_datetime(item.start_time) - utcnow()) < timedelta(minutes=5) %}
              {%- set final_buy_price = [adjusted_buy_price, item.per_kwh] | max %}
            {%- else %}
              {%- set final_buy_price = adjusted_buy_price %}
            {%- endif %}
            {%- set data.load_cost_list = data.load_cost_list + [final_buy_price | round(4)] %}
          {%- endif %}
        {%- endfor %}
        {#- Process SELL price forecasts (prod_price) using corrected logic #}
        {%- for item in state_attr('sensor.amber_5min_forecasts_extended_feed_in_price', 'Forecasts') %}
          {%- if as_datetime(item.start_time) > now %}
            {#- Step 1: Normalize feed-in prices to positive numbers to make logic clearer. #}
            {%- set p10_sell = -item.advanced_price_low %}
            {%- set p50_sell = -item.advanced_price_predicted %}

            {#- Step 2: Calculate the adjusted price on positive numbers. #}
            {#- This moves the price from p50 towards p10 (the more pessimistic value). #}
            {%- set adjusted_sell_price = p50_sell + (p10_sell - p50_sell) * k %}
            
            {#- Step 3: For the next interval, find the most conservative (minimum) positive price. #}
            {%- if (as_datetime(item.start_time) - utcnow()) < timedelta(minutes=5) %}
              {%- set per_kwh_sell = -item.per_kwh %}
              {%- set final_sell_price = [adjusted_sell_price, per_kwh_sell] | min %}
            {%- else %}
              {%- set final_sell_price = adjusted_sell_price %}
            {%- endif %}

            {%- set data.prod_price_list = data.prod_price_list + [final_sell_price | round(4)] %}
          {%- endif %}
        {%- endfor %}
        {#- ========================================================================================= #}
        {#-                    END: TWO-KNOB DYNAMIC PRICING LOGIC                        -#}
        {#- ========================================================================================= #}

        
        "load_power_forecast": {{ data.load_power_list[:144] | tojson }},
        "pv_power_forecast": {{ data.pv_power_list[:144] | tojson }},
        "load_cost_forecast": {{ data.load_cost_list[:144] | tojson }},
        "prod_price_forecast": {{ data.prod_price_list[:144] | tojson }},
        "weight_battery_discharge": {{ states('input_number.emhass_weight_battery_discharge') | float }},
        "optimization_time_step": 5,
        "prediction_horizon": 144
      }

  emhass_publish_data_mpc:
    url: http://emhass.REDACTED/action/publish-data
    method: POST
    headers:
      content-type: application/json
    payload: >-
      {
        "publish_prefix":"mpc"
      }

  emhass_publish_data_all:
    url: http://emhass.REDACTED/action/publish-data
    method: POST
    headers:
      content-type: application/json
    payload: >-
      {
        "publish_prefix":"all"
      }
